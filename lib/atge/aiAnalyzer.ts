/**
 * AI Trade Analyzer
 * 
 * Uses OpenAI o1-mini (ChatGPT-5.1) to analyze completed trades with advanced reasoning
 * Model is configurable via OPENAI_MODEL environment variable
 * Implements fallback to gpt-4o if o1 models timeout
 * Requirements: 7.1-7.15
 */

import OpenAI from 'openai';

// OpenAI o1 model configuration (ChatGPT-5.1)
// Primary: o1-mini for reasoning-based trade analysis
// Fallback: gpt-4o for speed when o1 models timeout
const MODEL = process.env.OPENAI_MODEL || 'o1-mini';
const FALLBACK_MODEL = process.env.OPENAI_FALLBACK_MODEL || 'gpt-4o';

// Timeout configuration
const O1_TIMEOUT = parseInt(process.env.O1_TIMEOUT || '120000'); // 120 seconds
const GPT4O_TIMEOUT = parseInt(process.env.GPT4O_TIMEOUT || '30000'); // 30 seconds

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface TradeAnalysisContext {
  tradeSignal: {
    symbol: string;
    entryPrice: number;
    tp1Price: number;
    tp2Price: number;
    tp3Price: number;
    stopLossPrice: number;
    timeframe: string;
    confidenceScore: number;
    marketCondition: string;
    aiReasoning: string;
    generatedAt: Date;
  };
  tradeResult: {
    actualEntryPrice: number;
    actualExitPrice?: number;
    tp1Hit: boolean;
    tp1HitAt?: Date;
    tp1HitPrice?: number;
    tp2Hit: boolean;
    tp2HitAt?: Date;
    tp2HitPrice?: number;
    tp3Hit: boolean;
    tp3HitAt?: Date;
    tp3HitPrice?: number;
    stopLossHit: boolean;
    stopLossHitAt?: Date;
    stopLossHitPrice?: number;
    profitLossUsd?: number;
    profitLossPercentage?: number;
    tradeDurationMinutes?: number;
  };
  technicalIndicators: {
    rsiValue?: number;
    macdValue?: number;
    macdSignal?: number;
    ema20?: number;
    ema50?: number;
    ema200?: number;
    bollingerUpper?: number;
    bollingerMiddle?: number;
    bollingerLower?: number;
    atrValue?: number;
  };
  marketSnapshot: {
    currentPrice: number;
    priceChange24h?: number;
    volume24h?: number;
    socialSentimentScore?: number;
    whaleActivityCount?: number;
    fearGreedIndex?: number;
  };
}

interface TradeAnalysis {
  outcome: 'success' | 'failure';
  profitLoss: number;
  profitLossPercentage: number;
  explanation: string;
  keyFactors: string[];
  whatWorked: string[];
  whatDidntWork: string[];
  marketConditionImpact: string;
  technicalIndicatorAccuracy: string;
  confidenceScoreReview: string;
  recommendations: string[];
  lessonsLearned: string[];
}

/**
 * Analyze a completed trade using OpenAI o1-mini (ChatGPT-5.1)
 * Model is configurable via OPENAI_MODEL environment variable
 * Implements fallback to gpt-4o if o1 models timeout
 * Requirements: 7.1-7.6
 */
export async function analyzeTradeWithAI(
  context: TradeAnalysisContext
): Promise<TradeAnalysis> {
  try {
    // Build comprehensive prompt with all context
    const prompt = buildAnalysisPrompt(context);

    // Try o1-mini first with 120-second timeout
    try {
      console.log('[ATGE] Analyzing trade with o1-mini...');
      const response = await Promise.race([
        openai.chat.completions.create({
          model: MODEL,
          messages: [
            {
              role: 'user',
              content: `You are an expert cryptocurrency trading analyst with advanced reasoning capabilities. Analyze this completed trade and provide detailed insights on why it succeeded or failed. Focus on:
1. Identifying key factors that contributed to the outcome
2. Evaluating the accuracy of technical indicators
3. Assessing market condition impact
4. Reviewing the AI's confidence score accuracy
5. Providing actionable recommendations for future trades
6. Extracting lessons learned

Be honest, analytical, and specific. Use data-driven reasoning.

${prompt}`
            }
          ],
          max_completion_tokens: 2000
        }),
        new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('o1-mini timeout')), O1_TIMEOUT)
        )
      ]);

      // Parse and validate response
      const analysisText = response.choices[0]?.message?.content;
      if (!analysisText) {
        throw new Error('No analysis generated by o1-mini');
      }

      // Extract reasoning if available
      const reasoning = response.choices[0]?.message?.reasoning;
      
      const analysis = JSON.parse(analysisText) as TradeAnalysis;

      // Add reasoning to explanation if available
      if (reasoning) {
        analysis.explanation = `${analysis.explanation}\n\n[o1 Reasoning]: ${reasoning}`;
      }

      // Validate required fields
      if (!analysis.outcome || !analysis.explanation || !analysis.keyFactors) {
        throw new Error('Invalid analysis structure from o1-mini');
      }

      console.log('[ATGE] Trade analysis completed with o1-mini');
      return analysis;
    } catch (o1Error) {
      console.error('[ATGE] o1-mini failed, trying gpt-4o fallback:', o1Error);
      
      // Fallback to gpt-4o
      const response = await Promise.race([
        openai.chat.completions.create({
          model: FALLBACK_MODEL,
          messages: [
            {
              role: 'system',
              content: `You are an expert cryptocurrency trading analyst. Your job is to analyze completed trades and provide detailed insights on why they succeeded or failed. Focus on:
1. Identifying key factors that contributed to the outcome
2. Evaluating the accuracy of technical indicators
3. Assessing market condition impact
4. Reviewing the AI's confidence score accuracy
5. Providing actionable recommendations for future trades
6. Extracting lessons learned

Be honest, analytical, and specific. Use data-driven reasoning.`
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          max_completion_tokens: 2000,
          response_format: { type: 'json_object' }
        }),
        new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('gpt-4o timeout')), GPT4O_TIMEOUT)
        )
      ]);

      // Parse and validate response
      const analysisText = response.choices[0]?.message?.content;
      if (!analysisText) {
        throw new Error('No analysis generated by gpt-4o');
      }

      const analysis = JSON.parse(analysisText) as TradeAnalysis;

      // Validate required fields
      if (!analysis.outcome || !analysis.explanation || !analysis.keyFactors) {
        throw new Error('Invalid analysis structure from gpt-4o');
      }

      console.log('[ATGE] Trade analysis completed with gpt-4o (fallback)');
      return analysis;
    }
  } catch (error) {
    console.error('[ATGE] AI trade analysis error:', error);
    
    // Return fallback analysis
    return generateFallbackAnalysis(context);
  }
}

/**
 * Build comprehensive analysis prompt
 */
function buildAnalysisPrompt(context: TradeAnalysisContext): string {
  const { tradeSignal, tradeResult, technicalIndicators, marketSnapshot } = context;

  // Determine outcome
  const isSuccess = (tradeResult.profitLossUsd ?? 0) > 0;
  const outcome = isSuccess ? 'PROFITABLE' : 'LOSS';

  // Calculate duration
  const durationHours = tradeResult.tradeDurationMinutes 
    ? (tradeResult.tradeDurationMinutes / 60).toFixed(1)
    : 'N/A';

  // Build targets hit summary
  const targetsHit = [];
  if (tradeResult.tp1Hit) targetsHit.push(`TP1 at $${tradeResult.tp1HitPrice?.toFixed(2)}`);
  if (tradeResult.tp2Hit) targetsHit.push(`TP2 at $${tradeResult.tp2HitPrice?.toFixed(2)}`);
  if (tradeResult.tp3Hit) targetsHit.push(`TP3 at $${tradeResult.tp3HitPrice?.toFixed(2)}`);
  if (tradeResult.stopLossHit) targetsHit.push(`Stop Loss at $${tradeResult.stopLossHitPrice?.toFixed(2)}`);

  return `Analyze this ${outcome} trade for ${tradeSignal.symbol}:

## TRADE OUTCOME
- Result: ${outcome}
- Profit/Loss: $${tradeResult.profitLossUsd?.toFixed(2)} (${tradeResult.profitLossPercentage?.toFixed(2)}%)
- Duration: ${durationHours} hours
- Targets Hit: ${targetsHit.join(', ') || 'None'}

## ORIGINAL TRADE SIGNAL
- Entry Price: $${tradeSignal.entryPrice.toFixed(2)}
- Take Profit 1: $${tradeSignal.tp1Price.toFixed(2)} (40% allocation)
- Take Profit 2: $${tradeSignal.tp2Price.toFixed(2)} (30% allocation)
- Take Profit 3: $${tradeSignal.tp3Price.toFixed(2)} (30% allocation)
- Stop Loss: $${tradeSignal.stopLossPrice.toFixed(2)}
- Timeframe: ${tradeSignal.timeframe}
- Confidence Score: ${tradeSignal.confidenceScore}%
- Market Condition: ${tradeSignal.marketCondition}
- AI Reasoning: "${tradeSignal.aiReasoning}"

## TECHNICAL INDICATORS AT GENERATION
- RSI: ${technicalIndicators.rsiValue?.toFixed(2) ?? 'N/A'}
- MACD: ${technicalIndicators.macdValue?.toFixed(2) ?? 'N/A'} (Signal: ${technicalIndicators.macdSignal?.toFixed(2) ?? 'N/A'})
- EMA 20: $${technicalIndicators.ema20?.toFixed(2) ?? 'N/A'}
- EMA 50: $${technicalIndicators.ema50?.toFixed(2) ?? 'N/A'}
- EMA 200: $${technicalIndicators.ema200?.toFixed(2) ?? 'N/A'}
- Bollinger Bands: Upper $${technicalIndicators.bollingerUpper?.toFixed(2) ?? 'N/A'}, Middle $${technicalIndicators.bollingerMiddle?.toFixed(2) ?? 'N/A'}, Lower $${technicalIndicators.bollingerLower?.toFixed(2) ?? 'N/A'}
- ATR: ${technicalIndicators.atrValue?.toFixed(2) ?? 'N/A'}

## MARKET CONDITIONS AT GENERATION
- Current Price: $${marketSnapshot.currentPrice.toFixed(2)}
- 24h Price Change: ${marketSnapshot.priceChange24h?.toFixed(2) ?? 'N/A'}%
- 24h Volume: $${marketSnapshot.volume24h?.toLocaleString() ?? 'N/A'}
- Social Sentiment Score: ${marketSnapshot.socialSentimentScore ?? 'N/A'}/100
- Whale Activity Count: ${marketSnapshot.whaleActivityCount ?? 'N/A'}
- Fear & Greed Index: ${marketSnapshot.fearGreedIndex ?? 'N/A'}/100

## ANALYSIS REQUIRED
Provide a comprehensive analysis in JSON format with the following structure:
{
  "outcome": "${isSuccess ? 'success' : 'failure'}",
  "profitLoss": ${tradeResult.profitLossUsd ?? 0},
  "profitLossPercentage": ${tradeResult.profitLossPercentage ?? 0},
  "explanation": "Detailed explanation of why this trade ${isSuccess ? 'succeeded' : 'failed'} (2-3 sentences)",
  "keyFactors": ["Factor 1", "Factor 2", "Factor 3"],
  "whatWorked": ["Aspect 1 that worked well", "Aspect 2 that worked well"],
  "whatDidntWork": ["Aspect 1 that didn't work", "Aspect 2 that didn't work"],
  "marketConditionImpact": "How the ${tradeSignal.marketCondition} market condition affected the trade",
  "technicalIndicatorAccuracy": "Assessment of how accurate the technical indicators were",
  "confidenceScoreReview": "Was the ${tradeSignal.confidenceScore}% confidence score justified? Why or why not?",
  "recommendations": ["Recommendation 1 for future trades", "Recommendation 2 for future trades"],
  "lessonsLearned": ["Lesson 1", "Lesson 2"]
}`;
}

/**
 * Generate fallback analysis when AI fails
 */
function generateFallbackAnalysis(context: TradeAnalysisContext): TradeAnalysis {
  const { tradeSignal, tradeResult } = context;
  const isSuccess = (tradeResult.profitLossUsd ?? 0) > 0;

  return {
    outcome: isSuccess ? 'success' : 'failure',
    profitLoss: tradeResult.profitLossUsd ?? 0,
    profitLossPercentage: tradeResult.profitLossPercentage ?? 0,
    explanation: isSuccess
      ? `This trade was profitable, reaching ${tradeResult.tp1Hit ? 'TP1' : ''}${tradeResult.tp2Hit ? ', TP2' : ''}${tradeResult.tp3Hit ? ', and TP3' : ''} before the ${tradeSignal.timeframe} timeframe expired.`
      : `This trade hit the stop loss at $${tradeResult.stopLossHitPrice?.toFixed(2)} before reaching any take profit levels.`,
    keyFactors: [
      `${tradeSignal.marketCondition} market condition`,
      `${tradeSignal.confidenceScore}% AI confidence score`,
      `${tradeSignal.timeframe} timeframe`
    ],
    whatWorked: isSuccess
      ? ['Price movement aligned with prediction', 'Technical indicators were accurate']
      : [],
    whatDidntWork: !isSuccess
      ? ['Price moved against prediction', 'Stop loss was triggered']
      : [],
    marketConditionImpact: `The ${tradeSignal.marketCondition} market condition ${isSuccess ? 'supported' : 'hindered'} the trade outcome.`,
    technicalIndicatorAccuracy: 'Technical indicators provided mixed signals.',
    confidenceScoreReview: `The ${tradeSignal.confidenceScore}% confidence score was ${isSuccess ? 'justified' : 'too optimistic'} given the outcome.`,
    recommendations: [
      'Continue monitoring market conditions',
      'Adjust confidence thresholds based on market volatility'
    ],
    lessonsLearned: [
      isSuccess ? 'This trade setup worked well' : 'This trade setup needs refinement',
      'Market conditions significantly impact trade outcomes'
    ]
  };
}

/**
 * Analyze patterns across multiple trades
 * Requirements: 7.8-7.12
 */
export async function analyzeTradePatterns(
  trades: Array<{
    signal: TradeAnalysisContext['tradeSignal'];
    result: TradeAnalysisContext['tradeResult'];
  }>
): Promise<{
  bestMarketConditions: string[];
  bestTimeframes: string[];
  averageConfidenceSuccess: number;
  averageConfidenceFailure: number;
  recommendations: string[];
}> {
  // Group trades by market condition
  const byMarketCondition: Record<string, { wins: number; losses: number; totalProfit: number }> = {};
  
  // Group trades by timeframe
  const byTimeframe: Record<string, { wins: number; losses: number; totalProfit: number }> = {};
  
  // Track confidence scores
  const successfulConfidences: number[] = [];
  const failedConfidences: number[] = [];

  for (const trade of trades) {
    const isSuccess = (trade.result.profitLossUsd ?? 0) > 0;
    const profit = trade.result.profitLossUsd ?? 0;

    // Market condition analysis
    if (!byMarketCondition[trade.signal.marketCondition]) {
      byMarketCondition[trade.signal.marketCondition] = { wins: 0, losses: 0, totalProfit: 0 };
    }
    if (isSuccess) {
      byMarketCondition[trade.signal.marketCondition].wins++;
    } else {
      byMarketCondition[trade.signal.marketCondition].losses++;
    }
    byMarketCondition[trade.signal.marketCondition].totalProfit += profit;

    // Timeframe analysis
    if (!byTimeframe[trade.signal.timeframe]) {
      byTimeframe[trade.signal.timeframe] = { wins: 0, losses: 0, totalProfit: 0 };
    }
    if (isSuccess) {
      byTimeframe[trade.signal.timeframe].wins++;
    } else {
      byTimeframe[trade.signal.timeframe].losses++;
    }
    byTimeframe[trade.signal.timeframe].totalProfit += profit;

    // Confidence tracking
    if (isSuccess) {
      successfulConfidences.push(trade.signal.confidenceScore);
    } else {
      failedConfidences.push(trade.signal.confidenceScore);
    }
  }

  // Find best market conditions (by profit)
  const bestMarketConditions = Object.entries(byMarketCondition)
    .sort((a, b) => b[1].totalProfit - a[1].totalProfit)
    .slice(0, 2)
    .map(([condition]) => condition);

  // Find best timeframes (by profit)
  const bestTimeframes = Object.entries(byTimeframe)
    .sort((a, b) => b[1].totalProfit - a[1].totalProfit)
    .slice(0, 2)
    .map(([timeframe]) => timeframe);

  // Calculate average confidence scores
  const averageConfidenceSuccess = successfulConfidences.length > 0
    ? successfulConfidences.reduce((a, b) => a + b, 0) / successfulConfidences.length
    : 0;

  const averageConfidenceFailure = failedConfidences.length > 0
    ? failedConfidences.reduce((a, b) => a + b, 0) / failedConfidences.length
    : 0;

  // Generate recommendations
  const recommendations: string[] = [];

  if (bestMarketConditions.length > 0) {
    recommendations.push(`Focus on ${bestMarketConditions.join(' and ')} market conditions for better results`);
  }

  if (bestTimeframes.length > 0) {
    recommendations.push(`${bestTimeframes.join(' and ')} timeframes show the best performance`);
  }

  if (averageConfidenceSuccess > averageConfidenceFailure + 10) {
    recommendations.push(`Higher confidence scores (>${Math.round(averageConfidenceFailure + 10)}%) correlate with better outcomes`);
  }

  if (recommendations.length === 0) {
    recommendations.push('Continue gathering data to identify patterns');
  }

  return {
    bestMarketConditions,
    bestTimeframes,
    averageConfidenceSuccess,
    averageConfidenceFailure,
    recommendations
  };
}
